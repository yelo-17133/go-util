# go-util

go-util 是对 golang 语言以及常用公共类库的封装，与业务逻辑无关，可随时用于任何项目。

主要包括以下几类：

### strUtil

字符串帮助类：

- case: 首字母大小写转换、在 CamelCase、SnakeCase、PascalCase、KebabCase 几种命名格式之间做转换。
- join: 扩展 strings.Join，允许将 []int、[]interface 类型拼接为字符串。
- rand: 随机字符串生成
- split: 扩展 strings.Split，允许将字符串拆分为 []int，且允许设置是否过滤空字符串等更多参数。
- stringBuilder: 当需要频繁拼接字符串时，可用此类代替字符串相加操作。备注：如果只是少量字符串的拼接，建议仍使用字符串相加，因少量拼接的情况下两者性能并无差别。
- 其他常用函数的封装

### arrUtil

对数组的封装。包括：

- convertor：从 []someType 转换为 []anotherType
- find：从 []someType 中查找符合条件的子集
- indexOf: 从 []someType 中查找符合条件的第一个元素的索引

### mapUtil

对 map 类型的封装：

- diff/union：求两个或多个 map 的交集/并集。
- equal: 比较两个或多个 map 是否相等（key、value都相等）

### timeUtil

对 time 包的封装：

- 增加了一个 JsonTime 类，在 json 序列化时默认按 “2006-01-02 15:04:05” 格式进行转换，而不是按 golang 默认方式转换。
- 增加了对时间的各种常用处理函数。
- 新增了一个可以随时调整间隔、随时启停的计时器。如果程序中有后台调度逻辑的计时间隔是基于可配置参数的，则可以灵活调整计时器间隔而不必重启进程。

### mathUtil

对 math 包的封装

- min/max: 求一组数字的最大或最小值
- sum: 求一组数字的和

### jsonUtil

对 json(jsoniter) 的封装：

- 默认开启 “弱类型解析”。比如一个字段声明的是 Id int，但 json 字符串中格式为 "id": "123"，仍然能够成功的将其解析为 Id=int(123)。其他类型同理。
- 针对常用的场景，对函数做了封装

### osUtil

对操作系统的信号做了封装，从而可以在进程退出前得到事件通知，允许应用程序在进程退出前执行自定义逻辑。

如果系统中申请了某些重要资源、且这些资源不会因为进程退出而被操作系统自动回收，那么应当在进程退出前释放这些资源，以免进程重启之后新的进程会因为资源不足而无法启动。

典型的比如分布式锁，在进程退出时就必须手动释放所有已经获得的锁。否则该锁就会长时间无法被其他模块获得。

### comparer

弱类型比较，比如比较一个整数和一个字符串是否相等、比较一个 interface 是否大于一个字符串。

需要注意的是：在比较两个对象时，会尝试将他们统一转化为同一种可以比较的类型。举例：在比较两个字符串时，如果发现两个字符串都能转化为数字，则按照数字比较逻辑比较，因此 "321" > "99" 会返回  true 而不是 false（按字符串比较时，会因为首字母 '3'<'9' 而返回 false）。

### convertor

类型转换，用于将 interface 对象转化为 bool|int|float|string 等类型。

### deepcopy

深拷贝的实现，源于github

### fileWatcher

文件监视器，通过定时器检测文件是否有改动，如果有则重新加载。

### httpClient

对 http.Client 的封装，增加了以下逻辑：

- 重新构造了 http.Client 连接池，解决在频繁调用 http.Client 时的资源泄露问题
- 增加自动重试机制，在调用远程接口时如果因为网络抖动等原因偶尔失败，httpClient 内部会自动解决，调用方不会感知到此类偶发性错误。
- 针对 Json Api 的调用做了进一步封装。

### jsonValidator

在 comparer 和 jsonUtil 的基础上，实现的 Json 表达式验证器。

比如给定一个 json 格式字符串和 {"result.data.count", "gt", 123} 表达式规则，即可获得其结果是否为真。可在需要不修改代码（不重新编译发布）就能动态修改匹配规则时使用。

### redisLock

基于 redis 实现的分布式锁。

详情参考代码注释。

### distdCache

基于 Redis pub/sub 实现的分布式内存缓存，用于在分布式系统中的多个节点保持一份一模一样的内存缓存（当其中一个节点更新缓存时，数据会被同步到整个分布式系统中）。

distdCache 的读操作都是访问的本地内存，没有网络开销。适用于需频繁访问、对数据一致性要求不是非常严格（允许有0~100ms延迟）、内存消耗不大（建议占用内存 <= 100M）的数据缓存。

如果对一致性要求非常高，需要用 Redis/Memcache 等远程分布式缓存 + 分布式锁来确保一致性。

更多内容见源代码注释。

### taskQueue/chanTaskQueue

基于 channel 实现的异步队列。

在异步处理数据时，一般针对每个数据启动一个协程来处理该数据。比如我们会监听某个消息队列，在消息队列中有新数据到达时就启动携程来处理他。

这种处理方式一般情况下不会有问题，但如果消息队列中的数据非常频繁、且每次数据处理耗时非常短，则此时会因为频繁的协程切换而导致浪费系统性能。协程的代价虽然比线程要少，但切换仍然有代价。

此时，一个更好的做法，就是使用 channel 处理，启动一个协程来处理该 chanel。这样可以避免频繁的协程切换。

同时，还可以通过控制 channel 大小来做服务容量限制，防止雪崩效应产生。

### taskQueue/redisTaskQueue

基于 Redis 实现的分布式任务队列，分布式系统中的多个节点共同处理同一个队列。

这样可以灵活扩展节点个数（队列处理程序），达到系统扩容。

### taskQueue/redisDelayTaskQueue

基于 Redis 实现的分布式延迟队列。

有时候，我们会需要程序在一段时间之后执行某个逻辑。比如 “用户登录满10分钟送xxx礼包”  等，我们可以在用户登录那一刻启动一个 10min 的计时器，计时器到达时给用户送礼包。

但这样的实现方案有个很大的弊端：在计时器触发之前，一旦进程被重启，则会因为计时器丢失，这个逻辑就再也不会被触发了。因此，正确的做法，应当是在用户登录那一刻，在系统的某个地方标记 10min 后需要给用户送礼包、同时启动一个扫描逻辑，不断的扫描截至当前时间有没有 “需要送礼包但尚未送” 的用户，如果有则送给他并标记为已送。

延迟队列，就是这样的一种允许指定延时的任务队列：当任务被丢到队列时，可以指定延迟多长时间，如果该时间大于0，则只有到达指定时间时该任务才会被发送到队列消费者那里。

如果所有任务在丢到队列里面时的延迟都是0，则延迟队列退化为普通队列，redisDelayTaskQueue 就变成了 redisTaskQueue。

延迟队列（redisDelayTaskQueue ）与普通队列（redisTaskQueue）的另一个不同之处在于：

在普通队列中，任务是没有唯一标识的，同样的数据如果向队列中放入两次，则会被消费两次。但延迟队列支持给任务设置唯一ID，如果同一个任务向队列中放入两次，则实际上后放入的数据会覆盖前一次的数据，从而实现一个任务只会被处理一次。

例如：如果需要“用户离线超过3天则向其发送通知”。当用户在t1登出系统时，可以向队列中增加一个通知任务，在t1+3day时触发。但第二天用户又登录了系统，并在t2时登出，则再次向队列中增加此任务（相同的任务ID），设为t2+3day触发。此时队列中仍然只有一个t2+3day的任务，在t1+3day的时候不会有任何事情发生。因为第二次增加任务时，实际上是修改了任务的执行时间，而不是增加了一个新的任务。

### timeRoundedCounter

基于时间周期的计数器，用来实现类似 “最近 N 个时间周期” 的性能记数。

如果进程内要对服务容量进行统计，比如统计最近60分钟内每分钟的Api请求数，则可以使用该组件：初始化一个周期为1分钟、共60各周期的计数器。每当有Api请求时，调用计数组件。这样在获取技术结果时，就能获得一个最长60个元素的数组，每个数组的数字就代表这一分钟内的api请求书。

可用来统计程序内部的负载，比如在处理异步队列时、处理api时计数，然后在压力过大时拒绝服务，或者在性能监测页面展示系统负载以便技术人员优化系统架构。

